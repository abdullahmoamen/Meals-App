{"ast":null,"code":"import sync from 'framesync';\nimport { copyAxisBox } from '../../../utils/geometry/index.js';\nimport { compareByDepth } from '../../utils/compare-by-depth.js';\n\nfunction updateTreeLayoutMeasurements(visualElement, isRelativeDrag) {\n  withoutTreeTransform(visualElement, function () {\n    var allChildren = collectProjectingChildren(visualElement);\n    batchResetAndMeasure(allChildren);\n    updateLayoutMeasurement(visualElement);\n  });\n  !isRelativeDrag && visualElement.rebaseProjectionTarget(true, visualElement.measureViewportBox(false));\n}\n\nfunction collectProjectingChildren(visualElement) {\n  var children = [];\n\n  var addChild = function addChild(child) {\n    child.projection.isEnabled && children.push(child);\n    child.children.forEach(addChild);\n  };\n\n  visualElement.children.forEach(addChild);\n  return children.sort(compareByDepth);\n}\n/**\n * Perform the callback after temporarily unapplying the transform\n * upwards through the tree.\n */\n\n\nfunction withoutTreeTransform(visualElement, callback) {\n  var parent = visualElement.parent;\n  var isEnabled = visualElement.projection.isEnabled;\n  isEnabled && visualElement.resetTransform();\n  parent ? withoutTreeTransform(parent, callback) : callback();\n  isEnabled && visualElement.restoreTransform();\n}\n/**\n * Update the layoutState by measuring the DOM layout. This\n * should be called after resetting any layout-affecting transforms.\n */\n\n\nfunction updateLayoutMeasurement(visualElement) {\n  var layoutState = visualElement.getLayoutState();\n  visualElement.notifyBeforeLayoutMeasure(layoutState.layout);\n  layoutState.isHydrated = true;\n  layoutState.layout = visualElement.measureViewportBox();\n  layoutState.layoutCorrected = copyAxisBox(layoutState.layout);\n  visualElement.notifyLayoutMeasure(layoutState.layout, visualElement.prevViewportBox || layoutState.layout);\n  sync.update(function () {\n    return visualElement.rebaseProjectionTarget();\n  });\n}\n/**\n * Record the viewport box as it was before an expected mutation/re-render\n */\n\n\nfunction snapshotViewportBox(visualElement) {\n  visualElement.prevViewportBox = visualElement.measureViewportBox(false);\n  /**\n   * Update targetBox to match the prevViewportBox. This is just to ensure\n   * that targetBox is affected by scroll in the same way as the measured box\n   */\n\n  visualElement.rebaseProjectionTarget(false, visualElement.prevViewportBox);\n}\n\nfunction batchResetAndMeasure(order) {\n  /**\n   * Write: Reset any transforms on children elements so we can read their actual layout\n   */\n  order.forEach(function (child) {\n    return child.resetTransform();\n  });\n  /**\n   * Read: Measure the actual layout\n   */\n\n  order.forEach(updateLayoutMeasurement);\n}\n\nexport { batchResetAndMeasure, collectProjectingChildren, snapshotViewportBox, updateLayoutMeasurement, updateTreeLayoutMeasurements, withoutTreeTransform };","map":{"version":3,"sources":["C:/Users/Abdullah/Desktop/React_course_UDEMY-resources/meal/node_modules/framer-motion/dist/es/render/dom/projection/utils.js"],"names":["sync","copyAxisBox","compareByDepth","updateTreeLayoutMeasurements","visualElement","isRelativeDrag","withoutTreeTransform","allChildren","collectProjectingChildren","batchResetAndMeasure","updateLayoutMeasurement","rebaseProjectionTarget","measureViewportBox","children","addChild","child","projection","isEnabled","push","forEach","sort","callback","parent","resetTransform","restoreTransform","layoutState","getLayoutState","notifyBeforeLayoutMeasure","layout","isHydrated","layoutCorrected","notifyLayoutMeasure","prevViewportBox","update","snapshotViewportBox","order"],"mappings":"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","sourcesContent":["import sync from 'framesync';\nimport { copyAxisBox } from '../../../utils/geometry/index.js';\nimport { compareByDepth } from '../../utils/compare-by-depth.js';\n\nfunction updateTreeLayoutMeasurements(visualElement, isRelativeDrag) {\n    withoutTreeTransform(visualElement, function () {\n        var allChildren = collectProjectingChildren(visualElement);\n        batchResetAndMeasure(allChildren);\n        updateLayoutMeasurement(visualElement);\n    });\n    !isRelativeDrag &&\n        visualElement.rebaseProjectionTarget(true, visualElement.measureViewportBox(false));\n}\nfunction collectProjectingChildren(visualElement) {\n    var children = [];\n    var addChild = function (child) {\n        child.projection.isEnabled && children.push(child);\n        child.children.forEach(addChild);\n    };\n    visualElement.children.forEach(addChild);\n    return children.sort(compareByDepth);\n}\n/**\n * Perform the callback after temporarily unapplying the transform\n * upwards through the tree.\n */\nfunction withoutTreeTransform(visualElement, callback) {\n    var parent = visualElement.parent;\n    var isEnabled = visualElement.projection.isEnabled;\n    isEnabled && visualElement.resetTransform();\n    parent ? withoutTreeTransform(parent, callback) : callback();\n    isEnabled && visualElement.restoreTransform();\n}\n/**\n * Update the layoutState by measuring the DOM layout. This\n * should be called after resetting any layout-affecting transforms.\n */\nfunction updateLayoutMeasurement(visualElement) {\n    var layoutState = visualElement.getLayoutState();\n    visualElement.notifyBeforeLayoutMeasure(layoutState.layout);\n    layoutState.isHydrated = true;\n    layoutState.layout = visualElement.measureViewportBox();\n    layoutState.layoutCorrected = copyAxisBox(layoutState.layout);\n    visualElement.notifyLayoutMeasure(layoutState.layout, visualElement.prevViewportBox || layoutState.layout);\n    sync.update(function () { return visualElement.rebaseProjectionTarget(); });\n}\n/**\n * Record the viewport box as it was before an expected mutation/re-render\n */\nfunction snapshotViewportBox(visualElement) {\n    visualElement.prevViewportBox = visualElement.measureViewportBox(false);\n    /**\n     * Update targetBox to match the prevViewportBox. This is just to ensure\n     * that targetBox is affected by scroll in the same way as the measured box\n     */\n    visualElement.rebaseProjectionTarget(false, visualElement.prevViewportBox);\n}\nfunction batchResetAndMeasure(order) {\n    /**\n     * Write: Reset any transforms on children elements so we can read their actual layout\n     */\n    order.forEach(function (child) { return child.resetTransform(); });\n    /**\n     * Read: Measure the actual layout\n     */\n    order.forEach(updateLayoutMeasurement);\n}\n\nexport { batchResetAndMeasure, collectProjectingChildren, snapshotViewportBox, updateLayoutMeasurement, updateTreeLayoutMeasurements, withoutTreeTransform };\n"]},"metadata":{},"sourceType":"module"}